---
title: "Modeling yield losses caused by the corn stunt disease complex "
author: "Marcelo Gonçalves"
warning: false
message: false
format: html
editor: visual
editor_options: 
  chunk_output_type: inline
---

# Libraries

Let's load all the packages we will use in the analyses below. Make sure all packages are installed beforehand. If you don't have them installed yet, you can install them from the CRAN repository.

```{r}
library(tidyverse)
library(gsheet)
library(ggplot2)
library(patchwork)
library(ggthemes)
library(metafor)
library(psych)
library(broom)
library(lme4)
library(car)
```

# Data import

First, we import two datasets from Google Sheets. `cs_data` contains the main dataset, while `tabela2` includes additional information for joining.

First, we import two datasets from Google Sheets. `cs_data` contains the main dataset, while `tabela2` includes additional information for joining. Next, we filter the data to remove rows with missing values and high total spots, and adjust the dataset for the subsequent analyses.

Since the severity scale does not include zero and a score of one represents the absence of the disease, we subtract 1 from the scale so that disease-free cases correspond to 0. This adjustment ensures that the intercept represents the attainable yield.

```{r}
cs_data <- gsheet2tbl(
  "https://docs.google.com/spreadsheets/d/1Q6ES9jfpAwq1apyz7OpyT4X3aYyN_gSyFPkg9x6xar4/edit?gid=0#gid=0")
tabela2 <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1Q6ES9jfpAwq1apyz7OpyT4X3aYyN_gSyFPkg9x6xar4/edit?gid=1802319739#gid=1802319739")

exp1 <- cs_data |> 
  filter(!is.na(prod),
         !is.na(enfez),
         enfez <= 6,
         manchas_totais < 5) |> 
  mutate(prod_class = ifelse(prod > 6377, "alta", "baixa")) |> 
  left_join(tabela2, by = "cultivar")


sev_dif <- exp1 |> 
  mutate(enfez = enfez - 1)


data1 <- sev_dif |> 
  group_by(estudo, tolerance_ad, cultivar, rep, cidade, ano, ensaio, prod_class, manchas_totais) |> 
  summarize(prod = prod,
            sev = enfez) |> 
  mutate(trial = interaction(cidade, ano, ensaio)) 

```

# Exploratory Data Analysis

Exploratory analyses were performed to check the data distribution. We used histograms and boxplots to provide a better description and visualization of the data.

### Median

```{r}
ef_median <- exp1 |> 
  group_by(estudo, ano, cultivar) |> 
  summarise(mean_sev = mean(enfez),
            mean_yld = mean(prod),
            median_sev = median(enfez),
            median_prod = median(prod))

ef_median |> 
  group_by(ano) |> 
  summarise(median_sev = mean(median_sev),
            median_prod = mean(median_prod))
```

```{r}
summary(ef_median)
```

### Histogram

```{r}
dist_sev <- ef_median |>
  ggplot(aes(median_sev)) +
  geom_histogram(bins = 10, 
                 fill = "gray90",
                 color = "black",
                 linewidth = 0.5) +
  labs(x = "Severity  score", y = "") +
  geom_vline(xintercept = 3.637, size = 1.3, linetype = 2)+
  theme_bw()


dist_prod<- ef_median |>
  ggplot(aes(median_prod)) +
  geom_histogram(bins = 20, fill = "gray90",
                 color = "black",
                 linewidth = 0.5) +
  labs(x = "Yield (kg/ha)", y = "") +
   geom_vline(xintercept = 6270, size = 1.3, linetype = 2)+
  theme_bw()
```

### Boxplot

```{r}
box_sev <- ef_median |>
  ggplot(aes(factor(ano), median_sev)) +
  geom_boxplot(outlier.shape = NA, fill = "gray90", color = "black") +
  theme_bw() +
  labs(x = "Second crop season", y = "Severity score")



box_prod<- ef_median |>
  ggplot(aes(factor(ano), median_prod)) +
  geom_boxplot(outlier.shape = NA, fill = "gray90", color = "black") +
  theme_bw() +
  labs(x = "Second crop season", y = "Yield (kg/ha)")

```

Final figure used in the article.

```{r}
Fig2 <- (dist_sev | box_sev)/
(dist_prod | box_prod) +
  plot_annotation(tag_levels = "A")
Fig2
```

### Individual regressions

Individual regression analyses were performed for each of the 22 studies to examine the trend in the relationship between the two variables (CSCD severity and corn yield).

```{r}
gc1 <- ef_median |> 
  ggplot(aes(mean_sev, mean_yld))+
  geom_smooth(method = "lm", se = FALSE, color = "#3A5FCD", fullrange = TRUE) +
  geom_point(color = "black", shape = 1) + 
  theme_bw() +
  facet_wrap(~estudo,
             ncol = 6) +
  labs(y = "Yield (Kg/ha)",x = "Severity score")

gc1
```

# Random coefficients model

We fitted a mixed-effects model to estimate the effect of severity on yield, including random slopes and intercepts for each study to account for variation among studies.

```{r}
mm1 <- lmer(prod ~ sev  + (sev | estudo), data = data1,
            REML = TRUE)
summary(mm1)
confint(mm1)
VarCorr(mm1)

isSingular(mm1)

performance::r2(mm1)

performance::icc(mm1)



```

### Table 1. Summary of the random-coefficients mixed-effects model describing the relationship between disease severity and yield across 22 trials

| **Parameter** | **Estimate ± SE** | **95 % CI (LCL–UCL)** | **Interpretation** |
|:-----------------|-----------------:|-----------------:|:-----------------|
| **Fixed effects** |  |  |  |
| Intercept (β₀) | 8 229 ± 215 | 7 820 – 8 640 | Attainable (disease-free) yield (kg ha⁻¹) |
| Severity (β₁) | −1 043 ± 112 | −1 260 – −830 | Yield loss per unit increase in severity |
| **Random effects (SD)** |  |  |  |
| Intercept (study) | 2 512 |  | Between-study heterogeneity in attainable yield |
| Slope (study) | 315 |  | Between-study heterogeneity in loss rate |
| Corr (intercept, slope) | −0.51 |  | High-yield studies show steeper losses |
| **Model fit indices** |  |  |  |
| Marginal R² / Conditional R² | 0.58 / 0.72 |  | Variance explained by fixed vs. full model |
| Residual SD | 1 265 |  | Within-study variation |
| ICC (inter-study) | 0.46 |  | Proportion of variance between studies |

------------------------------------------------------------------------

*Model fitted by restricted maximum likelihood (REML).\
95 % confidence intervals obtained by profile likelihood. R² values computed following Nakagawa and Schielzeth (2013).*

We calculate confidence intervals for the mixed-effects model using the profile likelihood

```{r}
confint(mm1, method = "profile")  # Interval based on likelihood profile
```

Data distribution from individual analyses of 22 studies. Blue points represent observed data, and gray lines indicate individual linear regressions.

Calculation of the damage coefficient by yield level

```{r}
library(dplyr)
library(tibble)
library(purrr)

# model_full: lmer(prod ~ Sprime + (Sprime | STUDY), data = df) or your extended model
fe <- fixef(mm1)
re <- ranef(mm1)$estudo %>%
  rownames_to_column("estudo") %>%
  rename(b0 = `(Intercept)`, b1 = sev)  # rename 'Sprime' to your severity term name

# Study-specific intercepts and slopes
study_lines <- re %>%
  mutate(alpha = fe["(Intercept)"] + b0,
         gamma = fe[["sev"]]      + b1,
         RDC   = gamma / alpha)

# Median split on intercept
med_alpha <- median(study_lines$alpha, na.rm = TRUE)
study_lines <- study_lines %>%
  mutate(intercept_stratum = if_else(alpha > med_alpha, "High", "Low"))

# Stratified summaries (means)
summary_RDC <- study_lines %>%
  group_by(intercept_stratum) %>%
  summarise(n = n(),
            mean_alpha = mean(alpha),
            mean_gamma = mean(gamma),
            mean_RDC   = mean(RDC),
            sd_RDC     = sd(RDC), .groups = "drop")

# Optional: bootstrap 95% CI for mean RDC by stratum
set.seed(123)
B <- 2000
boot_out <- map_dfr(c("High","Low"), function(strat){
  x <- study_lines %>% filter(intercept_stratum == strat) %>% pull(RDC)
  means <- replicate(B, mean(sample(x, replace = TRUE)))
  tibble(intercept_stratum = strat,
         RDC_lo = quantile(means, 0.025),
         RDC_hi = quantile(means, 0.975))
})

summary_RDC <- left_join(summary_RDC, boot_out, by = "intercept_stratum")
print(summary_RDC)




# ---- Build mean lines per stratum ----
stratum_lines <- summary_RDC %>%
  transmute(
    intercept_stratum,
    intercept = mean_alpha,
    slope     = mean_gamma
  )

library(dplyr)
library(ggplot2)

# Build mean lines per stratum if not already built
stratum_lines <- summary_RDC %>%
  transmute(intercept_stratum,
            intercept = mean_alpha,
            slope     = mean_gamma)

# Choose the x-range you want to display (use 0–5 if S' = S-1)
x_min <- 0
x_max <- 5

# Compute segment endpoints
seg <- stratum_lines %>%
  mutate(x0 = x_min,
         x1 = x_max,
         y0 = intercept + slope * x0,
         y1 = intercept + slope * x1)

# Plot the segments
ggplot(seg) +
  geom_segment(aes(x = x0, xend = x1, y = y0, yend = y1, color = intercept_stratum),
               linewidth = 1.8, lineend = "round") +
  scale_color_manual(values = c(High = "#1f77b4", Low = "#d62728"),
                     name = "Intercept stratum") +
  scale_x_continuous(limits = c(x_min, x_max), expand = c(0, 0)) +
  # Set y-limits to include both segment endpoints
  scale_y_continuous(limits = range(c(seg$y0, seg$y1)), expand = expansion(mult = 0.02)) +
  labs(x = "Severity (rescaled S' = S - 1)",
       y = "Yield (kg/ha)",
       title = "Mean yield–severity lines for High vs Low intercept strata") +
  theme_bw()

```

```{r}

fig3a <- ggplot() +
  scale_x_continuous(breaks = 0:5, limits = c(0, 5)) +
  scale_y_continuous(breaks = seq(0, 14000, by = 2000), limits = c(0, 14000)) +
  geom_abline(aes(slope = study_lines$gamma, intercept = study_lines$alpha), 
              size = 1, alpha = 0.5, color = "darkgray") +
 geom_point(data = ef_median, aes(x = mean_sev-1, y = mean_yld),
             color = "black", shape = 16, alpha = 0.3) +
  labs(x = "Severity (rescaled S' = S - 1)", y = "Yield (kg/ha)") +
  theme_bw() +
  theme(text = element_text(size = 20),
        axis.text.x = element_text(size = 18),
        axis.text.y = element_text(size = 18),
        plot.title = element_text(hjust = 0.5, size = 18))
fig3a

```

Meta-analysis using a mixed-effects model. Blue line represents the average estimated relationship (common slope), and black dashed lines indicate the 95% confidence interval for the average regression.

```{r}
r_regression_misto <- data.frame(
  estimate = c(8227.42, -1042.59),
  low = c(7050.872811 , -1217.903252),
  high = c(9342.37841711, -869.23656135)
)

fig3b <- ggplot() +
  scale_x_continuous(breaks = 0:5, limits = c(0, 5)) +
  scale_y_continuous(breaks = seq(0, 14000, by = 2000), limits = c(0, 14000)) +
  geom_abline(data = r_regression_misto, 
              aes(slope = estimate[2], intercept = estimate[1]), 
              size = 1.5, color = "black") +
  geom_abline(data = r_regression_misto, 
              aes(intercept = high[1], slope = high[2]), 
              size = 1.2, linetype = 2) +
  geom_abline(data = r_regression_misto, 
              aes(intercept = low[1], slope = low[2]), 
              size = 1.2, linetype = 2) +
  labs(x = "Severity (rescaled S' = S - 1)", y = "Yield (kg/ha)") +
  theme_bw() +
  theme(text = element_text(size = 20),
        axis.text.x = element_text(size = 18),
        axis.text.y = element_text(size = 18),
        plot.title = element_text(hjust = 0.5, size = 18))
fig3b
```

```{r}

library(patchwork)
fig3a + fig3b


```

Calculation of damage when the disease reaches the maximum severity score.

```{r}
   
y1 = 8227.34

y6 = 8227.34 + (-1042.59 * 5)

max_damage = ((y1 - y6) / y1) * 100
max_damage
```

# Creation of susceptibility levels

We fitted a mixed-effects model for severity, considering random effects of hybrid, year, study, and their interaction, and extracted BLUPs for each hybrid. The BLUPs were scaled, and a Euclidean distance matrix was calculated to perform hierarchical clustering using Ward’s method. The dendrogram was cut into two groups, classifying hybrids with higher BLUPs as susceptible and those with lower BLUPs as moderately susceptible, and the results were visualized for interpretation.

```{r}
# Ensure factors
df <- data1 |> 
  mutate(
    HYBRID = as.factor(cultivar),
    YEAR = as.factor(ano),
    LOC = as.factor(estudo),
    REP = as.factor(rep)
  )

# Fit mixed model: random effect for HYBRID, optionally random LOC:YEAR
model <- lmer(
  sev ~ 1 + (1|HYBRID) + (1|YEAR) + (1|LOC) ,
  data = df, REML = TRUE,
  control = lmerControl(
    optimizer = "bobyqa",
    optCtrl = list(maxfun = 2e5)
  )
)
allfits <- lme4::allFit(update(model, control = lmerControl(optimizer="bobyqa")))
summary(allfits)


blups <- ranef(model)$HYBRID |> 
  rownames_to_column("HYBRID") |> 
  rename(BLUP = '(Intercept)') |> 
  arrange(BLUP)

blups2 <- ranef(model)$HYBRID |> 
  rownames_to_column("HYBRID") |> 
  rename(BLUP = '(Intercept)') |> 
  arrange(BLUP)

# Assuming 'blups' contains HYBRID and BLUP columns from lmer
blup_matrix <- blups |> 
  column_to_rownames("HYBRID")

# Scale the BLUPs (optional but common in clustering)
blup_scaled <- scale(blup_matrix)

# Compute distance and apply hierarchical clustering
dist_blup <- dist(blup_scaled)
clust <- hclust(dist_blup, method = "ward.D2")

# Cut the tree into 2 groups
blups$GROUP <- cutree(clust, k = 2)

# Optional: sort for interpretation
blups <- blups  |> 
  arrange(BLUP) |> 
  mutate(cultivar = HYBRID) |> 
  select(cultivar, GROUP)

blups_final <- left_join(blups, blups2, by = c("cultivar" = "HYBRID"))


# View the clustered groups
print(blups)

fig_blups <- factoextra::fviz_dend(
  clust,
  k = 2,                                # number of groups
  rect = FALSE,                          # draw rectangles around groups
  rect_fill = TRUE,                     # fill the rectangles
  rect_border = "gray30",              # color of the rectangle borders
  cex = 0.8,                            # size of the label text
  k_colors = c("#3A5FCD", "red"),      # colors of the groups
  color_labels_by_k = TRUE,            # color labels according to groups
  labels_track_height = 0.8,           # height of the label track
  horiz = TRUE,
  main = " ",
  ) +  labs(y = "Euclidean distance ") +
  theme(axis.text.x = element_text(size = 18),
        axis.title.x = element_text(size = 20) # increase numbers on the Y axis
  ) +
  theme_bw()
print(fig_blups)

```

Data preparation

```{r}
data2 <- left_join(data1, blups)


data3 <- data2 |> 
  group_by(estudo, tolerance_ad, cultivar, GROUP, prod_class) |> 
  summarize(sev = mean(sev),
            prod = mean(prod))


```

```{r}
# Fit random coefficients model: varying intercept and slope by STUDY

df <- data3 |> 
  mutate(GROUP = factor(GROUP),
         STUDY = factor(estudo))  # If not already a factor


model0 <- lmer(prod ~ sev  + (sev | STUDY), data = df, REML = FALSE)
model <- lmer(prod ~ sev * GROUP + (sev | STUDY), data = df, REML = FALSE)
anova(model0, model)
car::Anova(model)

# Random effect structure
ranef(model)

# Optional: extract slope and intercept per STUDY
coef(model)$STUDY


```

# Covariates

### Susceptibility levels used as a fixed covariate

Adding the interaction between severity and susceptibility group did not improve the model fit, indicating that severity affects production similarly across groups.

```{r}
# susceptibility levels

model_full <- lmer(prod ~ sev * GROUP + (sev | STUDY), data = df, REML = FALSE)
model_no_interaction <- lmer(prod ~ sev + GROUP + (sev | STUDY), data = df, REML = FALSE)
model_no_group <- lmer(prod ~ sev + (sev | STUDY), data = df, REML = FALSE)
anova(model_no_group, model_no_interaction, model_full)

```

### Tolerance group used as covariate

Adding the interaction between severity and tolerance group did not improve the model fit, indicating that severity affects production similarly across groups.

```{r}
# tolerance group
df2 <- data1 |> 
  mutate(tolerance_ad = factor(tolerance_ad),
         estudo = factor(estudo))

model_full <- lmer(prod ~ sev * tolerance_ad + (sev | estudo), data = df2, REML = FALSE)
model_no_interaction <- lmer(prod ~ sev + tolerance_ad + (sev | estudo), data = df2, REML = FALSE)
model_no_group <- lmer(prod ~ sev + (sev | estudo), data = df2, REML = FALSE)
anova(model_no_group, model_no_interaction, model_full)
```

### Foliar spot pressure used as a moderator

Adding the interaction between severity and foliar spot pressure did not improve the model fit, indicating that severity affects production similarly across groups.

```{r}
#foliar spot pressure
med_spots <- sev_dif |> 
  summarise(med_spots = median(manchas_totais, na.rm = TRUE)) |> 
  pull(med_spots)

df5 <- sev_dif |> 
  mutate(spot_press = factor(ifelse(manchas_totais > med_spots, "alta", "baixa")))

model_full <- lmer(prod ~ enfez * spot_press + (enfez | estudo), data = df5, REML = FALSE)
model_no_interaction <- lmer(prod ~ enfez + spot_press + (enfez | estudo), data = df5, REML = FALSE)
model_no_group <- lmer(prod ~ enfez + (enfez | estudo), data = df5, REML = FALSE)
anova(model_no_group, model_no_interaction, model_full)
        

```
